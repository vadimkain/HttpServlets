<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<style>
    body {
        max-width: 60%;
        min-height: 400vh;
        margin-left: 10%;
        text-align: justify;
    }
</style>
<body>
<h1>HTTP. Servlets. 26. HttpServlet. Жизненный цикл сервлетов</h1>
<p>Apache Tomcat - это всего лишь сервер, у которого есть три модуля:</p>
<ul>
    <li>Catalina - является servlet контейнером</li>
    <li>Coyote - является HTTP коннектором</li>
    <li>Jasper - является engine'ом</li>
</ul>
<img src="commit-26-1.png" width="40%"/>
<h2>Заглянем внутрь Apache Tomcat и посмотрим более детально, как устроен этот сервер</h2>
<img src="commit-26-2.png" alt="" width="70%">
<p>Он состоит из трёх основных компонентов, но разберём два из них: Coyote (коёт*) и Catalina (каталина*)</p>
<br>
<p>
    Когда клиент отправляет HTTP запрос (клиентов может быть все что угодно) и наш коёт HTTP connector - это всего
    лишь набор классов, которые представляют собой что-то вроде <code>ServerSocket()</code>, который принимает
    HTTP запросы. По сути, он открывает TCP порт на том хосте, на котором развернуто приложение. В нашем случае
    это localhost. Следовательно, мы будем отправлять запросы на localhost:8080. И наш коёт получает сокет от HTTP
    запроса, по сути просто вызывает метод <code>.except()</code> у <code>ServerSocket()</code> и оборачивает его
    в свой java класс, который называется <b><code>Request()</code></b> (<code>coyote.Request</code>), который лежит
    в пакете Coyote (<b>каждый из этих модулей - это всего лишь пакет в java приложении</b>).
</p>
<br>
<p>
    Далее, этот <code><code>coyote.Request</code></code> переходит на каталину. Т.е. это ещё один модуль в apache
    tomcat, по другому говоря ещё какой-то пакет с набором классов, который отвечает за <i>сервлеты</i>. Т.е.
    каталина является сервлет-контейнером (servlet container). На схеме, справа от желтого блока с каталиной изображен
    кусок кода (естественно, в каталине все намного сложнее).
    <br><br>
    Сервлет контейнер это по сути всего
    лишь ассоциативный массив. Т.е. коллекция, которая включает в себя набор сервлетов. Следовательно, сервлет это
    всего лишь класс, который наследуется от <code>HttpServlet()</code>. Этот класс есть в Apache Tomcat. В этом
    ассоциативном массиве каждому сервлету соответствует какой-то ключ. Этим ключом является <b>url</b>, а именно
    путь в этом url (то, что подчеркнуто красным цветом,
    <code>localhost:8080<span style="color: red">/users</span>?param=value</code>). Не хост, не порт, потому что это
    не относится к определению сервлета, это относится лишь к тому, где запущен наш сервер. А вот путь как раз нужен
    для определения маппинга сервлета на url.
    <br>
    <img src="commit-26-4.png" alt="">
    <br>
    Т.к. по одному url есть одно значение в ассоциативном массиве, следовательно, сервлеты, каждый из объектов класса
    <code>HttpServlet()</code>, который будем создавать, — это <i>SINGLETON</i> (т.е. существует лишь один экземпляр
    какого-то класса сервлет). После чего (<b>2</b>), как мы получили этот сервлет, мы оборачиваем
    <code>coyoteRequest()</code> и <code>coyoteResponse()</code> в обёртки, которые использует каталина
    (<code>HttpServletRequest</code> & <code>HttpServletResponse</code>) и передаёт его уже нашему сервлету в метод
    <code>.service(request, response)</code>.
    <br><br>
    Но есть нюанс: с методом <code>.load()</code>, который запускается в момент, когда в ассоциативном массиве не было
    сервлета по данному url. Следственно, происходит его загрузка. Отсюда вытекает три основных шага, которые и
    являются жизненным циклом сервлета:
    <br>
    <img src="commit-26-3.png" alt="">
    <br>
<ol>
    <li>
        <b>Первый шаг</b> срабатывает один единственный раз, на самый первый request, который пришёл на сервлет. Это и
        есть
        функция <code>load</code>, которая инициализирует сервлет. И инициализация включает три шага: загрузка класса
        в память JVM (потому что все наши сервлеты это скомпилированные классы, которые пакуем в war и загружаем в
        webapps
        папку. Следовательно, т.к. это сторонний класс, нам нужно его просто загрузить в JVM в нашем Apache Tomcat.
        Потому
        что Apache Tomcat это тоже java приложение и он должен знать про этот класс, чтобы с ним работать. Далее,
        <b>второй шаг</b>, это просто создание объекта нашего класса-сервлета. Опять же, т.к. объект будет только один,
        нам нужен только один экземпляр класса Servlet. И т.к. мы не знаем как создавать наш объект, потому что он
        абстрактный. Мы знаем, что он только наследуется от HttpServlet, нам нужно будет использовать
        <b>Reflection API</b>. После чего, как у нас появился объект класса сервлет, мы вызываем у него метод
        <code>.init()</code> (invoke <code>servlet.init()</code>).
    </li>
    <li>
        Далее, мы вызываем лишь метод <code>.service()</code> (invoke <code>servlet.service()</code>). каждый раз при
        каждом последующем запросе, мы вызываем у нашего сервлета метод <code>.service()</code>. Следовательно, наша
        задача как раз таки определить функциональность, написать её, которая будет вызываться из нашего метода
        <code>.service()</code>.
    </li>
    <li>
        invoke <code>servlet.destroy()</code> вызывается только в том случае, когда мы завершаем работу нашего Apache
        Tomcat, либо делаем undeploy приложения (удаляем приложение из папки webapps, тогда вызывается метод
        <code>.destroy()</code>).
    </li>
</ol>
Разберём более детально первый шаг, а именно как он выглядит в коде (код упрощён):
<br>
<img src="commit-26-5.png" alt="" width="50%">
<br>
Суть в том, что Load, это всего лишь мы берём у объекта <code>classLoader.loadClass(className)</code> и передаём в
метод название сервлета. Он загрузит его в память и получит объект класса <code>Class< ? ></code>. После чего, мы
получаем конструктор без параметров нашего класса (<code>servletClass.getConstructor()</code>), это обязательное
требование, потому что мы не знаем как инициализировать наш сервлет и получив конструктор, всё что нам необходимо
сделать - это у этого конструктора без параметров вызвать метод <code>.newInstance()</code>. После чего получаем
объект класса <code>HttpServlet</code>, это будет его наследник. И последний шаг - это инициализация -
<code>servlet.init();</code>. И в методе <code>.init()</code> уже можем проинициализировать сервлет как захотим.
</p>
</body>
</html>